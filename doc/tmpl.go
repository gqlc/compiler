package doc

import (
	"fmt"
	"github.com/gqlc/graphql/ast"
	"strings"
	"text/template"
)

var docTmpl = template.New("docTmpl")

type typeSlice []*ast.TypeSpec

func (s typeSlice) Len() int           { return len(s) }
func (s typeSlice) Less(i, j int) bool { return s[i].Name.Name < s[j].Name.Name }
func (s typeSlice) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }

type mdData struct {
	DocName    string
	Title      string
	Schema     *ast.TypeSpec
	RootTypes  typeSlice
	Scalars    typeSlice
	Objects    typeSlice
	Interfaces typeSlice
	Unions     typeSlice
	Enums      typeSlice
	Inputs     typeSlice
	Directives typeSlice
}

func (d *mdData) HasSchema() bool {
	return d.Schema != nil
}

func (d *mdData) RootOps() (ops []string) {
	for _, op := range d.Schema.Type.(*ast.TypeSpec_Schema).Schema.RootOps.List {
		ops = append(ops, op.Name.Name)
	}
	return
}

const mdTmpl = `# {{.Title}}
*This was generated by gqlc.*

## Table of Contents{{if .HasSchema}}
- [Schema](#schema){{range .RootOps}}
	* [{{Title .}}](#{{.}}){{end}}{{end}}{{with .Scalars}}
- [Scalars](#scalars){{range .}}{{$name := .Name.Name}}
	* [{{$name}}](#{{ToLower $name}}){{end}}{{end}}{{with .Objects}}
- [Objects](#objects){{range .}}{{$name := .Name.Name}}
	* [{{$name}}](#{{ToLower $name}}){{end}}{{end}}{{with .Interfaces}}
- [Interfaces](#interfaces){{range .}}{{$name := .Name.Name}}
	* [{{$name}}](#{{ToLower $name}}){{end}}{{end}}{{with .Unions}}
- [Unions](#unions){{range .}}{{$name := .Name.Name}}
	* [{{$name}}](#{{ToLower $name}}){{end}}{{end}}{{with .Enums}}
- [Enums](#enums){{range .}}{{$name := .Name.Name}}
	* [{{$name}}](#{{ToLower $name}}){{end}}{{end}}{{with .Inputs}}
- [Inputs](#inputs){{range .}}{{$name := .Name.Name}}
	* [{{$name}}](#{{ToLower $name}}){{end}}{{end}}{{with .Directives}}
- [Directives](#directives){{range .}}{{$name := .Name.Name}}
	* [{{$name}}](#{{ToLower $name}}){{end}}{{end}}{{if .HasSchema}}

## Schema
Supported Operations:{{range .RootOps}} [{{Title .}}](#{{.}}),{{end}}{{with .Schema.Doc}}

{{Trim .Text}}{{end}}{{range (ToObjData .RootTypes)}}

{{template "objTmpl" .}}{{end}}{{end}}{{with .Scalars}}

## Scalars{{range .}}{{$name := .Name.Name}}

### {{$name}}{{with .Directives}}
*Directives*:{{range .}} {{PrintDir .}},{{end}}{{end}}{{with .Doc}}

{{Trim .Text}}{{end}}{{end}}{{end}}{{with .Objects}}

## Objects{{range (ToObjData .)}}

{{template "objTmpl" .}}{{end}}{{end}}{{with .Interfaces}}

## Interfaces{{range (ToObjData .)}}

{{template "objTmpl" .}}{{end}}{{end}}{{with .Unions}}

## Unions{{range .}}{{$name := .Name.Name}}

### {{$name}}{{with .Directives}}

*Directives*:{{range .}} {{PrintDir .}},{{end}}{{end}}{{with .Type}}

*Member Types*:{{range (ToMembers .)}} **[{{.Name}}](#{{ToLower .Name}})**,{{end}}{{end}}{{with .Doc}}

{{Trim .Text}}{{end}}{{end}}{{end}}{{with .Enums}}

## Enums{{range (ToObjData .)}}

{{template "objTmpl" .}}{{end}}{{end}}{{with .Inputs}}

## Inputs{{range (ToObjData .)}}

{{template "objTmpl" .}}{{end}}{{end}}{{with .Directives}}

## Directives{{range (ToObjData .)}}

{{template "objTmpl" .}}{{end}}{{end}}`

// ToObjData converts a typeSlice into the more friendly []objData
func ToObjData(list []*ast.TypeSpec) (objs []*objData) {
	for _, ts := range list {
		obj := &objData{
			Name:       ts.Name.Name,
			Directives: ts.Directives,
		}
		objs = append(objs, obj)

		if ts.Doc != nil {
			obj.Descr = ts.Doc.Text()
		}

		switch v := ts.Type.(type) {
		case *ast.TypeSpec_Schema:
			obj.Fields = v.Schema.RootOps
		case *ast.TypeSpec_Object:
			obj.Fields = v.Object.Fields
			for _, oi := range v.Object.Interfaces {
				obj.Interfaces = append(obj.Interfaces, oi.Name)
			}
		case *ast.TypeSpec_Interface:
			obj.Fields = v.Interface.Fields
		case *ast.TypeSpec_Enum:
			obj.Fields = v.Enum.Values
		case *ast.TypeSpec_Input:
			obj.Fields = v.Input.Fields
		case *ast.TypeSpec_Directive:
			obj.Fields = v.Directive.Args
			for _, l := range v.Directive.Locs {
				obj.Locs = append(obj.Locs, l.Loc.String())
			}

		// Ignore these
		case *ast.TypeSpec_Scalar:
		case *ast.TypeSpec_Union:
		}
	}
	return
}

type objData struct {
	Name, Descr string
	Interfaces  []string
	Directives  []*ast.DirectiveLit
	Fields      *ast.FieldList
	Locs        []string // to facilitate directive decls
}

const objTmpl = `### {{.Name}}{{with .Interfaces}}

*Interfaces*:{{range .}} [{{.}}](#{{ToLower .}}),{{end}}{{end}}{{with .Directives}}

*Directives*:{{range .}} {{PrintDir .}},{{end}}{{end}}{{with .Locs}}

*Locations*:{{range .}} {{.}},{{end}}{{end}}{{with .Descr}}

{{Trim .}}{{end}}{{if gt (len .Fields.List) 0}}{{with .Fields}}

*Fields*:
{{template "fieldListTmpl" .}}{{end}}{{end}}`

type fieldData struct {
	Name       string
	Type       string
	Default    string
	Directives []*ast.DirectiveLit
	Descr      string
	Args       *ast.FieldList
}

// ToFieldData converts a ast.FieldList into the more friendly []fieldData
func ToFieldData(list []*ast.Field) (fields []fieldData) {
	for _, f := range list {
		data := fieldData{
			Name:  f.Name.Name,
			Descr: f.Doc.Text(),
		}

		var typeName string
		typeTmpl := "%s"

		ft := f.Type
	typeLbl:
		switch v := ft.(type) {
		case *ast.Field_Ident:
			switch v.Ident.Name {
			case "Int", "String", "ID", "Boolean", "Float":
				typeName = v.Ident.Name
			default:
				typeName = fmt.Sprintf("[%s](#%s)", v.Ident.Name, strings.ToLower(v.Ident.Name))
			}
			data.Type = fmt.Sprintf(typeTmpl, typeName)
		case *ast.Field_List:
			switch u := v.List.Type.(type) {
			case *ast.List_Ident:
				ft = &ast.Field_Ident{Ident: u.Ident}
			case *ast.List_List:
				ft = &ast.Field_List{List: u.List}
			case *ast.List_NonNull:
				ft = &ast.Field_NonNull{NonNull: u.NonNull}
			}
			typeTmpl = fmt.Sprintf("[%s]", typeTmpl)
			goto typeLbl
		case *ast.Field_NonNull:
			switch u := v.NonNull.Type.(type) {
			case *ast.NonNull_Ident:
				ft = &ast.Field_Ident{Ident: u.Ident}
			case *ast.NonNull_List:
				ft = &ast.Field_List{List: u.List}
			}
			typeTmpl = fmt.Sprintf("%s!", typeTmpl)
			goto typeLbl
		}

		// TODO: Handle ListLit and ObjLit
		def := f.Default
		switch v := def.(type) {
		case *ast.Field_BasicLit:
			data.Default = v.BasicLit.Value
		case *ast.Field_CompositeLit:
		}

		if len(f.Directives) > 0 {
			data.Directives = f.Directives
		}

		if f.Args != nil {
			data.Args = f.Args
		}

		fields = append(fields, data)
	}
	return
}

const fieldListTmpl = `{{$fields := ToFieldData .List}}{{$Len := add (len $fields) -1}}{{range $i, $v := $fields}}- {{$v.Name}}{{with $v.Type}}

	*Type*: **{{.}}**{{end}}{{with $v.Default}} = {{.}}{{end}}{{with $v.Directives}}

	*Directives*:{{range .}} {{PrintDir .}},{{end}}{{end}}{{with $v.Descr}}

	{{Trim $v.Descr}}{{end}}{{with $v.Args}}{{if gt (len .List) 0}}

	*Args*:
{{$args := ToFieldData .List}}{{$aLen := add (len $args) -1}}{{range $j, $w := $args}}	- {{$w.Name}}

		*Type*: **{{$w.Type}}**{{with $w.Default}} = {{.}}{{end}}{{with $w.Directives}}
		*Directives*:{{range .}} {{PrintDir .}},{{end}}{{end}}{{with $w.Descr}}

		{{Trim $w.Descr}}{{end}}{{if ne $j $aLen}}

{{end}}{{end}}{{end}}{{end}}{{if ne $i $Len}}

{{end}}{{end}}`
