package doc

import (
	"fmt"
	"github.com/gqlc/graphql/ast"
	"strings"
	"text/template"
)

var docTmpl = template.New("docTmpl")

type typeSlice []*ast.TypeSpec

func (s typeSlice) Len() int           { return len(s) }
func (s typeSlice) Less(i, j int) bool { return getName("", s[i].Name) < getName("", s[j].Name) }
func (s typeSlice) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }

type mdData struct {
	DocName    string
	Title      string
	Imports    []string
	Schema     *ast.TypeSpec
	RootTypes  typeSlice
	Scalars    typeSlice
	Objects    typeSlice
	Interfaces typeSlice
	Unions     typeSlice
	Enums      typeSlice
	Inputs     typeSlice
	Directives typeSlice
}

func (d *mdData) HasSchema() bool {
	return d.Schema != nil
}

func (d *mdData) RootOps() (ops []string) {
	for _, op := range d.Schema.Type.(*ast.SchemaType).Fields.List {
		ops = append(ops, op.Name.Name)
	}
	return
}

// TODO: Add imports
const mdTmpl = `# {{.Title}}{{$docName := .DocName}}
*This was generated by gqlc.*{{if gt (len .Imports) 0}}

*Imports*:{{range .Imports}} {{.}},{{end}}{{end}}

## Table of Contents{{if .HasSchema}}
- [Schema](#schema){{range .RootOps}}
	* [{{Title .}}](#{{.}}){{end}}{{end}}{{with .Scalars}}
- [Scalars](#scalars){{range .}}{{$name := GetName $docName .Name}}
	* [{{$name}}](#{{ToLower $name}}){{end}}{{end}}{{with .Objects}}
- [Objects](#objects){{range .}}{{$name := GetName $docName .Name}}
	* [{{$name}}](#{{ToLower $name}}){{end}}{{end}}{{with .Interfaces}}
- [Interfaces](#interfaces){{range .}}{{$name := GetName $docName .Name}}
	* [{{$name}}](#{{ToLower $name}}){{end}}{{end}}{{with .Unions}}
- [Unions](#unions){{range .}}{{$name := GetName $docName .Name}}
	* [{{$name}}](#{{ToLower $name}}){{end}}{{end}}{{with .Enums}}
- [Enums](#enums){{range .}}{{$name := GetName $docName .Name}}
	* [{{$name}}](#{{ToLower $name}}){{end}}{{end}}{{with .Inputs}}
- [Inputs](#inputs){{range .}}{{$name := GetName $docName .Name}}
	* [{{$name}}](#{{ToLower $name}}){{end}}{{end}}{{with .Directives}}
- [Directives](#directives){{range .}}{{$name := GetName $docName .Name}}
	* [{{$name}}](#{{ToLower $name}}){{end}}{{end}}{{if .HasSchema}}

## Schema
Supported Operations:{{range .RootOps}} [{{Title .}}](#{{.}}),{{end}}{{with .Schema.Doc}}

{{Trim .Text}}{{end}}{{range (ToObjData $docName .RootTypes)}}

{{template "objTmpl" .}}{{end}}{{end}}{{with .Scalars}}

## Scalars{{range .}}{{$name := GetName $docName .Name}}

### {{$name}}{{with .Dirs}}
*Directives*:{{range .}} {{PrintDir .}},{{end}}{{end}}{{with .Doc}}

{{Trim .Text}}{{end}}{{end}}{{end}}{{with .Objects}}

## Objects{{range (ToObjData $docName .)}}

{{template "objTmpl" .}}{{end}}{{end}}{{with .Interfaces}}

## Interfaces{{range (ToObjData $docName .)}}

{{template "objTmpl" .}}{{end}}{{end}}{{with .Unions}}

## Unions{{range .}}{{$name := GetName $docName .Name}}

### {{$name}}{{with .Dirs}}

*Directives*:{{range .}} {{PrintDir .}},{{end}}{{end}}{{with .Type}}

*Member Types*:{{range (ToMembers $docName .)}} {{if IsImported .}}{{.}}{{else}}**[{{.}}](#{{ToLower .}})**{{end}},{{end}}{{end}}{{with .Doc}}

{{Trim .Text}}{{end}}{{end}}{{end}}{{with .Enums}}

## Enums{{range (ToObjData $docName .)}}

{{template "objTmpl" .}}{{end}}{{end}}{{with .Inputs}}

## Inputs{{range (ToObjData $docName .)}}

{{template "objTmpl" .}}{{end}}{{end}}{{with .Directives}}

## Directives{{range (ToObjData $docName .)}}

{{template "objTmpl" .}}{{end}}{{end}}`

// ToObjData converts a typeSlice into the more friendly []objData
func ToObjData(docName string, list []*ast.TypeSpec) (objs []*objData) {
	for _, ts := range list {
		obj := &objData{
			Name:       getName(docName, ts.Name),
			Directives: ts.Dirs,
		}
		objs = append(objs, obj)

		if ts.Doc != nil {
			obj.Descr = ts.Doc.Text()
		}

		switch v := ts.Type.(type) {
		case *ast.SchemaType:
			obj.Fields = v.Fields
		case *ast.ObjectType:
			obj.Fields = v.Fields
			for _, oi := range v.Impls {
				obj.Interfaces = append(obj.Interfaces, getName(docName, oi))
			}
		case *ast.InterfaceType:
			obj.Fields = v.Fields
		case *ast.EnumType:
			obj.Fields = v.Fields
		case *ast.InputType:
			obj.Fields = v.Fields
		case *ast.DirectiveType:
			obj.Fields = v.Args
			for _, l := range v.Locs {
				obj.Locs = append(obj.Locs, l.Loc.String())
			}

		// Ignore these
		case *ast.ScalarType:
		case *ast.UnionType:
		}
	}
	return
}

type objData struct {
	Name, Descr string
	Interfaces  []string
	Directives  []*ast.DirectiveLit
	Fields      *ast.FieldList
	Locs        []string // to facilitate directive decls
}

const objTmpl = `### {{.Name}}{{with .Interfaces}}

*Interfaces*:{{range .}} {{if IsImported .}}{{.}}{{else}}[{{.}}](#{{ToLower .}}){{end}},{{end}}{{end}}{{with .Directives}}

*Directives*:{{range .}} {{PrintDir .}},{{end}}{{end}}{{with .Locs}}

*Locations*:{{range .}} {{.}},{{end}}{{end}}{{with .Descr}}

{{Trim .}}{{end}}{{if gt (len .Fields.List) 0}}{{with .Fields}}

*Fields*:
{{template "fieldListTmpl" .}}{{end}}{{end}}`

type fieldData struct {
	Name       string
	Type       string
	Default    string
	Directives []*ast.DirectiveLit
	Descr      string
	Args       *ast.FieldList
}

// ToFieldData converts a ast.FieldList into the more friendly []fieldData
func ToFieldData(list []*ast.Field) (fields []fieldData) {
	for _, f := range list {
		data := fieldData{
			Name:  f.Name.Name,
			Descr: f.Doc.Text(),
		}

		var typeName string
		typeTmpl := "%s"

		ft := f.Type
	typeLbl:
		switch v := ft.(type) {
		case *ast.Ident:
			switch v.Name {
			case "Int", "String", "ID", "Boolean", "Float":
				typeName = v.Name
			default:
				typeName = fmt.Sprintf("[%s](#%s)", v.Name, strings.ToLower(v.Name))
			}
			data.Type = fmt.Sprintf(typeTmpl, typeName)
		case *ast.SelectorExpr:
			typeName = fmt.Sprintf("%s.%s", v.X.(*ast.Ident).Name, v.Sel.Name)
			data.Type = fmt.Sprintf(typeTmpl, typeName)
		case *ast.List:
			ft = v.Type
			typeTmpl = fmt.Sprintf("[%s]", typeTmpl)
			goto typeLbl
		case *ast.NonNull:
			ft = v.Type
			typeTmpl = fmt.Sprintf("%s!", typeTmpl)
			goto typeLbl
		}

		// TODO: Handle ListLit and ObjLit
		def := f.Default
		switch v := def.(type) {
		case *ast.BasicLit:
			data.Default = v.Value
		case *ast.ListLit:
		case *ast.ObjLit:
		}

		if len(f.Dirs) > 0 {
			data.Directives = f.Dirs
		}

		if f.Args != nil {
			data.Args = f.Args
		}

		fields = append(fields, data)
	}
	return
}

const fieldListTmpl = `{{$fields := ToFieldData .List}}{{$Len := add (len $fields) -1}}{{range $i, $v := $fields}}- {{$v.Name}}{{with $v.Type}}

	*Type*: **{{.}}**{{end}}{{with $v.Default}} = {{.}}{{end}}{{with $v.Directives}}

	*Directives*:{{range .}} {{PrintDir .}},{{end}}{{end}}{{with $v.Descr}}

	{{Trim $v.Descr}}{{end}}{{with $v.Args}}{{if gt (len .List) 0}}

	*Args*:
{{$args := ToFieldData .List}}{{$aLen := add (len $args) -1}}{{range $j, $w := $args}}	- {{$w.Name}}

		*Type*: **{{$w.Type}}**{{with $w.Default}} = {{.}}{{end}}{{with $w.Directives}}
		*Directives*:{{range .}} {{PrintDir .}},{{end}}{{end}}{{with $w.Descr}}

		{{Trim $w.Descr}}{{end}}{{if ne $j $aLen}}

{{end}}{{end}}{{end}}{{end}}{{if ne $i $Len}}

{{end}}{{end}}`
